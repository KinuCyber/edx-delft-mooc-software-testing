## | Requirements |
The instructions regarding what the program is supposed to do.

## | Partitions |
Different cases that a particular program can has.
This is figured out in two ways: Functional Testing & Structural Testing

## | Equivalent Partitioning |
Partitions that will give same results upon different inputs are
equivalent and, hence, such partitions must be tested once.

Example: Input is age (1-100)

Equivalence partitions:-
1-100 : Valid
<1 : Invalid
>100 : Invalid

Test Cases :-
Input: 25; Expected: Valid
Input: 0; Expected: Invalid
Input: 300; Expected: Invalid

## | Categorical Partitioning |
This is a more complicated approach, as followed :-
- Identify the conditions/parameters
- The characteristics of each parameter
-- From the specs (requirements)
-- Not from the specs (requirements)
- Add constraints (minimize)
-- Remove invalid combinations
-- Reduce numbers of exceptional behaviors
- Generate combinations

## | Categorical Partitioning -> Equivalent Partitioning |
Equivalent Partitioning is often used inside Categorical Partitioning
- EP helps define choices for a category
- CP combines and constraints those choices across the category

| Boundary Testing |
Testing done between the partitions.
Commonly bugs with <=, &&, etc
These "off-by-one" mistakes are very common in real life.

| Boundary Analysis |
Looking between boundaries of partitions to see what happens if our input
is between this boundary.

`On-Point`
The number that's exactly on the boundary

`Off-Point`
Closest number to the on-point that flips the condition

`In-Points`
Numbers that make our conditions always true

`Out-Points`
Numbers taht make our condition always false

`Examples`

Consider                    "x >= 5"
"                           ________
                               |
      OUT-POINTS               |                   IN-POINTS
                               |
                               |
                               |
  ...  -1   0   1   2   3   4  |5   6   7   8   ...
O---O---O---O---O---O---O---O--|O---O---O---O---O---O---O---O---O---O
                    OFF-POINT  |  ON-POINT
                               |
                               |
                               |
As such, the boundaries of "x >= 5" is as followed :-
On-point:      5
Off-point:     4
Out-points: ...4
In-points:     5...


Consider                     "x > 5"
"                             _______
                                 |
      OUT-POINTS                 |                   IN-POINTS
                                 |
                                 |
                                 |
  ...  -1   0   1   2   3   4   5|   6   7   8   ...
O---O---O---O---O---O---O---O---O|---O---O---O---O---O---O---O---O---O
                    ON-POINT     |  OFF-POINT
                                 |
                                 |
                                 |
As such, the boundaries of "x >= 5" is as followed :-
On-point:      5
Off-point:     6
Out-points: ...5
In-points:     6...

`How to handle boundaries`
- Handle each boundary independently
- For each boundary, pick on and off points.
- While testing one boundary, use varying in points for the remaining
  boundaries

| CORRECT Nomenclature |
Conformance: Standardized output (like emails must be user@domain format)
Ordering: Input ordering affects the output or not
Range: Defined limit for input (like 0 > age > 120)
Reference: The input/ouput may require a previous state
Existence: The inputs may not exact (entering null or whitespaces)
Cardinality: Off-by-one errors (forgetting to iterate the last item)
Time: What happens if input has wrong time (date/time)
