## | Code Smells |
In a code, Code smells are symptoms or indications of a deeper problem in
the system. A code that has low comprehensibility (hard to understand) is
considered smelly.

The same idea applies to "Test Smells".

## | AAA (Arrange, Act, Assess) |
AAA is the nomenclature that code testing follows

`Arrange` : The inputs and preparations for testing, such
partition planning, inputs and object declarations

`Act` : The operations and processes done upon the arrangements
to achieve final output.

`Assess` : Checking outputs, figuring out failures, documenting everything

## | FIRST Nomenclature |
FIRST nomenclature are a set of properties of a good test.

`Fast` : Tests should be fast. One way is to minimize the amount of
slow dependencies (mocks)

`Isolated` : These are two ways: "Functional Isolation" & "Test Isolation"

"Function isolation" is to conduct a test specifically for that
function such as a particular partition.

"Test isolation" is to ensure that a test does not rely on other tests and
can be tested by itself, such as if two tests share same DB then they
clear their values in DB to avoid affecting one another.

`Repeatable` : A repeatable test is one that always produces the same
results, regardless of how many times it is ran

`Self-validating` : Tests without assertions are not good automated tests. 
They must assess by themselves instead of requiring
manual verification.

That also means a test must be self-arranging. It is responsible for
making sure that all the required initial state are there before the
test runs.

`Timely` : To write tests alongside experimental/production code instead
of postponing them

## | Code Smell Symptoms |

`Duplicated Code` : Codes that have been duplicated across instead of
being abstracted. This makes it hard to change the duplicated code
across the program.

`Assertion Roulette` : Having too many assertions in a single method
makes it hard to recognize the issue when an assertion fails

`Slow Tests` : Developers are inclined to not run their code through
tests if it is slow

`Resource Optimism` : Believing that the resources is always available
for the tests, such as a database or web services. This can be
mitigated in two ways :-
1. Avoid using external resources (mocks)
2. If resources are critical, ensure that the test is resilient enough by
outputing "Resources are unavailable. This test can't continue" is
better than failing entirely.

`Test Run War` : Test runs fine when done by tester, however it fails
when done by colleagues. This can be due to :-
- Tester locking themselves in their development environment
- Multiple machines are manipulating the same data

`General Fixture` : Writing a very large fixture (arrangement) for every
method even if individual test methods don't utilize all the whole of it.
This makes it hard for developers to understand.

To mitigate "General Fixture", ensure that tests contain clear and concise
fixtures and never more than needed.

`Indirect Tests` : A test class that indirectly tests other classes
instead of focusing on its own class that needs to be tested. This
leads to multiple test classes failing even if one class has a bug.

` Sensitive Equality` : The assertions are so specific or sensitive to
small changes that they fail with any change in production code. The
test must be resillient as much as possible.

## | Test Data Builder |

`Problem`
Oftentimes, when arranging data for tests, it gets really
complicated like
`Inv i1 = new Inv(100.0, new User("Mauricio", new Addr("Netherlands")),..);`
Such codes are also prone to change (such as change in parameter), and 
would require changes across all the tests.

`Solution`
Encapsulating the creation of the test objects in another class with sole
responsiblity for the creation of the object is a design pattern called
"Test Data Builder", which is derivative of "Builder" pattern.

## | Flaky Test |
A test that passes sometimes but fails sometimes.
Flaky tests lowers the confidence of developers.
Possible causes :-
- External Infrastructure (database, web service, etc)
- Shared Resources (multiple machines manipulating same test data)
- Timeouts (web apps, etc)
- Interacting Tests (Tests that depend on each other)

Flaky tests are often results of code smells.

Solution: xUnit Test Patterns' Decision Table

## | Test Readability |
Tests are often used by developers to figure out what went wrong.
Hence, they must be readable by developers and anyone else involved.

` Structure `
The "Arrange, Act, Assess" blocks make it easy for developers to
understand the test by identifying such blocks.
Giving lines between the AAA blocks.

` Information `
Making information easy to understand, such as creating variables (with
proper names) to enter as arguments instead of entering raw data.

Tip: use "any" as a prefix in variable if it's not important for test
