## | Unit Testing |

A unit of work can be a single method, a whole class or multiple classes
working together to achieve one single logical purpose that can be verified

Unit Testing: Dedicated, isolated testing per unit

| Advantages | Disadvantages |
| --- | --- |
| Very Fast | | Some bugs can't be reproduced |
| Easy to control (parameterized) | Less real |
| Easy to write | | 

## | Integration Test |

Tests interface between components or interactions to different part of the
system such as OS, file system, hardware, other interfaces, etc


## | System Testing or Black Box Testing |

| Advantages | Disadvantages |
| Realistic | Very Slow |
| User perspective | Hard to write |
| Flaky | |



System Testing: 

## | Testing Pyramid |

Prioritize Units Tests -> Integration Tests -> System Tests -> Manual Tests

Unit Test: Any rule that can be standardized, such as roman numerals or package management
Itegration Test: Whenever different parts of the system interacts.
System Test: Only to test non-stopping parts (such as payment process in online shop)
Manual Test: Exploratory testing, to find edge cases and general humane exploration


## | Mock Objects |

An object that simulates another components, such as database, file system, etc, to test
the real test. This helps in avoiding "complex integration for tests' sake", testing
untestable things (like database crashing, otherwise we'd need to shutdown database to test)

Mocks can be of multiple aspects, such as Exceptions, Database Access, third-party libraries,
interfaces, complex classes, etc

## | Mockito |

A Java mocking framework to help simulate external components of a program.

## | Design for Testability |

A code that is easy to be tested and easy to write an automated test for.
If you cannot easily invoke a method to create class and check its output, the code is not designed with testability in mind

Changing production code to accomodate testing is a normal and common approach.
The domain model, the core, must be far from the infrastructure through classes, constructions and other forms.

Ports and Adapters helps separate domain model (business rules) from the infrastructure.

## | Ports |

Ports are the methods through which the domain model access outside information.
Ports are agnostic and know nothing.

## | Adapters |

Adapters provide the outside data to the ports of the domain.

## | Cohesive Class |
A class is cohesive when it does just one thing, having a single responsiblity. 

## | Coupling |

If classes depend on 10 classes then we would sometimes need 10 mocks. That's too much coupling.
Avoid over-coupling, and group dependencies or creating bigger abstractions.

## | Complex Conditions |
Complex conditions should be reduced to multiple simpler tests, such as MC/DC approach.

## | Domain-Driven Design |
Philosophy: Domain is the heart of the system. It needs to be separate from infra.

## |  Dependence Inversion Principle |
Dependencing Inversion is about how classes are designed, with following in mind :-
- High-level modules should not depend on low-level modules. Both depend on abstraction
- Abstractions should not depend on details. Details should depend on abstractions.

It makes us thing what parts of our system are abstraction and what are low-level details.

## | Dependence Injection Principle |

A software design principle that enables loose coupling between compoments.
An example is to provide a dependency from outside (e.g. through contructor)
instead of creating it internally, which makes it modular and flexible.

## | Controllability |
Determines the work it takes to set up and run test cases and the extent to which individual functions and features of the system under test (SUT) can be made to respond to test cases.

## | Observability |
Determines the work it takes to set up and run test cases and the extent to which the response of the system under test (SUT) to test cases can be verified.

| Tips |

Avoid static methods! They are the enemies of stability because they cannot be tested.

Feel the need to test a private class? If a private production method needs to be tested in isolated manner, it most likely means that it should be refactored into separate classes. Testing private methods through public methods.
